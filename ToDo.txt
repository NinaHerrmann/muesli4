Matmult: (+)
========
- paralleles Arbeiten auf allen Partitionen von DMs, z.B. mit Alg. v. Gentleman
- mit mapPartition (GPU aware) und permutePartion 

FSS / PSO -
=========
bis zu dreistufige Parallelit√§t: kommunizierenden Teams von Partikeln mit vielen Dimensionen
denkbar: Team verwendet Teil der Knoten, alle Partikel eines Teams per MPI; Dimensionen parallel auf Cores und GPUs
(z.B. Farm von Prozessen mit geschachtelten DAs; pro Team: Folge von map + fold

ACO -
===
abwechselnd:
  parallele Bearbeitung aller Ants (DA oder geschachteltes DA)
  parallele Bearbeitung aller Teillˆsungen (DA?)

Evolution√§re Algorithmen 
========================
- parallele Bestimmung der Fitness aller Individuen
- Auswahl der √úberlebenden (filter: -) 
- paarweise Kreuzung der √úberlebenden
- Aufnahme der Neugeborenen
- ggf. Inseln und Wanderungsbewegungen
- Ansatz: Insel pro Knoten; auf Cores und GPUs jedes Knotens: parallele Bearbeitung von Individuen und Paaren
          mit geschachteltem DA

Mandelbrot: +
===========
a) DM 
b) DA-Simulation von DM wobei jeder Index j = x + c y repr√§sentiert z = x + i*y

Nbody: 
======
abwechselnd  
  parallele Berechnung aller Kr√§fte zwischen je zwei K√∂rpern (mapPartition und permutePartition auf DA von struct)
  parallele Anwendung aller relevanten Kr√§fte auf jeden K√∂rper
  
Raytracing (+?)
==========
parallele Bearbeitung aller Bildpunkte  (map auf DM oder DA-Simulation von DM)

Monte-Carlo +
===========
- parallele Bearbeitung aller zuf√§llig gew√§hlten Suchraumelemente (map auf DA oder DM)
- am Ende: fold

******************************************************************************************************

insgesamt n√∂tig:
================
- filter und redistribute
- mapPertition f√ºr GPUs
- geschachtelte(s) DA /DM (denn DA / DM bieten nur ein Level von Parallelit√§t) -> zwei Levels von Parallelit√§t
   (DA / DM von struct von DA /DM simulierbar durch geschachteltes DA / DM + DA / DM von struct)
- foldRow f√ºr DM (FSS, PSO)   




